#!/usr/bin/perl

use Time::HiRes qw(gettimeofday);
use POSIX qw(mktime strftime);
use Time::Local qw(timegm);
use Socket qw(SOCK_RAW AF_INET inet_ntoa inet_aton sockaddr_in pack_sockaddr_in unpack_sockaddr_in);

my $ip;
my $ping_count = 0;
my $interval = 1;
my $raw_timestamps = 0;
my $fix_icmp_timestamps = 0;
for ($i = 0; $i < scalar(@ARGV); $i++) {
	if ($i == scalar(@ARGV) - 1) {
		if ($ARGV[$i] !~ /\d+\.\d+\.\d+\.\d+/) {
			$ip = `nslookup $ARGV[$i] 2>&1 | grep "Address 1" | sed -e 's/Address 1: //g'`;
			chomp($ip);
			if ($ip !~ /\d+\.\d+\.\d+\.\d+/) {
				die("Failed to resolve hostname \"$ARGV[$i]\"\n");
			}
		} else {
			$ip = $ARGV[$i];
		}
	} elsif ($ARGV[$i] eq "-c") {
		$ping_count = $ARGV[$i+1];
		$i++;
	} elsif ($ARGV[$i] eq "-i") { 
		$interval = $ARGV[$i+1];
		$i++;
	} elsif ($ARGV[$i] eq "-r") {
		$raw_timestamps = 1;
	} elsif ($ARGV[$i] eq "-f") {
		$fix_icmp_timestamps = 1;
	} else {
		&usage();
	}
}

if (scalar(@ARGV) == 0 || !defined($ip)) {
        &usage();
}

my $timeout = $interval;

my $minimum_rtt;
my $offset;

my $packet_id = $$;
my $seq;

# Create the socket
my $fd = &create_icmp_socket();

my $remaining = $ping_count;
while ($ping_count == 0 || $remaining > 0) {
	# Send an ICMP timestamp request
	my ($id, $seq) = &send_icmp_timestamp_request($ip, $fd);

	# Wait for the ICMP timestamp response
	my $timed_out = 0;
	my ($orig, $recv, $tran, $end) = &receive_icmp_timestamp_response($id, $seq, $timeout);

	my $rtt;
	if (defined($orig) && defined($recv) && defined($tran) && defined($end)) {
		if ($fix_icmp_timestamps) {
			($orig, $recv, $tran, $end) = &correct_icmp_timestamps($orig, $recv, $tran, $end);
		}
		
		# Calculate the one-way-delays and rtt
		my $tx_time = $recv - $orig;
		my $rx_time = $end - $tran;
		$rtt = $end - $orig;
		
		print("[" . &get_time() . "] dest=$ip id=$id seq=$seq orig=$orig recv=$recv tran=$tran end=$end tx=$tx_time rx=$rx_time rtt=$rtt");
		
		if ($fix_icmp_timestamps) {
			print(" offset=$offset\n");
		} else {
			print("\n");
		}
		
		
	} else {
		# Request timed out
		print("[" . &get_time() . "] dest=$ip id=$id seq=$seq TIMED OUT\n");
		$timed_out = 1;
	}

	if ($ping_count > 0) {
		$remaining--;
	}

	if (($ping_count == 0 || $remaining > 0) && !$timed_out) {
		select(undef, undef, undef, $interval - ($rtt/1000));
	}
}


##################################################################################
# Subroutines
##################################################################################

use constant ICMP_PROTOCOL         => 1;
use constant ICMP_TIMESTAMP        => 13;
use constant ICMP_TIMESTAMP_REPLY  => 14;
use constant ICMP_TIMESTAMP_STRUCT => "C2 n3 N3"; # Structure of a ICMP timestamp packet

sub usage {
	print("Usage\n");
	print("  ping_ts [options] <destination>\n");
	print("\n");
	print("Options\n");
	print("  <destination>      Hostname or IP address\n");
	print("  -c <count>         Stop after <count> pings\n");
	print("  -i <interval>      Seconds between ping requests\n");
	print("  -r                 Print raw log timestamps (seconds since the epoch)\n");
	print("  -f                 Attempt to fix ICMP timestamps\n");
	exit(1);
}

# Create a new ICMP socket
# Returns the file descriptor
sub create_icmp_socket {
	my $fd;
	socket($fd, AF_INET, SOCK_RAW, ICMP_PROTOCOL) || die("ICMP socket error - $!");
	return $fd;
}

# Update the sequence number
sub update_seq {
	if (defined($seq)) {
		$seq = ($seq + 1) % 65536;
	} else {
		$seq = 1
	}
}

# Get the number of milliseconds since midnight
sub get_ms_since_midnight {
	# Get the number of milliseconds since midnight UTC

	# Today's date in UTC
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday) = gmtime();

	# Epoch time for 00:00 this morning (UTC)
	$midnight_utc_ms = timegm(0, 0, 0, $mday, $mon, $year) * 1000;

	# Return the difference between the two
	return &round(gettimeofday() * 1000) - $midnight_utc_ms;
}

# Send an ICMP timestamp request tp the specified IP address, on the specified socket
# Returns the packet ID and sequence number for the message that was sent
sub send_icmp_timestamp_request {
	my ($ip, $fd) = @_;

	# Update the sequence number
	&update_seq();

	# Get the number of milliseconds since midnight UTC
	my $ms_since_midnight = &get_ms_since_midnight();

	# Construct the ICMP message
	my $msg = pack(ICMP_TIMESTAMP_STRUCT, ICMP_TIMESTAMP, 0, 0, $packet_id, $seq, $ms_since_midnight, 0, 0);

	# Calculate the checksum
	my $checksum = &get_checksum($msg);

	# Add the checksum to the message
	$msg = pack(ICMP_TIMESTAMP_STRUCT, ICMP_TIMESTAMP, 0, $checksum, $packet_id, $seq, $ms_since_midnight, 0, 0);

	# Send the message
	send($fd, $msg, 0, pack_sockaddr_in(0, inet_aton($ip)));

	# Return the ID and sequence number
	return ($packet_id, $seq);
}

# Subroutine to calculate an internet checksum (taken from Net::Ping.pm)
sub get_checksum {
	my ($msg) = @_;

	my $len_msg = length($msg);
	my $num_short = int($len_msg / 2);
	my $chk = 0;
  
	foreach $short (unpack("n$num_short", $msg)) {
		$chk += $short;
	}
	
	# Add the odd byte in
	$chk += (unpack("C", substr($msg, $len_msg - 1, 1)) << 8) if $len_msg % 2;

	$chk = ($chk >> 16) + ($chk & 0xffff);      # Fold high into low

	return(~(($chk >> 16) + $chk) & 0xffff);    # Again and complement
}

# Wait up to the specified timeout for an ICMP timestamp response corresponding
# to the specified packet ID and sequence number.
sub receive_icmp_timestamp_response {
	my ($id, $seq, $timeout) = @_;

	# Calculate our maximum finish time based on the specified timeout
	my $finish_time = gettimeofday() + $timeout;

	my $rin = "";
	vec($rin, $fd->fileno(), 1) = 1;
	my $done = 0;
	while (!$done && $timeout > 0) {
		# Block and wait for a packet
		my $nfound = select((my $rout = $rin), undef, undef, $timeout);

		my $end_ts = &get_ms_since_midnight();

		# Calculate the time we have left
		$timeout = $finish_time - gettimeofday();

		if ($nfound != -1) {
			# Receive the packet and get the IP (port will always be zero)
			my $recv_msg;
			my ($from_port, $from_ip) = unpack_sockaddr_in(recv($fd, $recv_msg, 1500, 0));

			# Get the payload from the packet
			my $pl_offset = 20;
			my ($reply_type, $reply_subcode) = unpack("C2", substr($recv_msg, $pl_offset, 2));

			# Check whether this is the timestamp reply that we're looking for
			my $reply_id = -1;
			my $reply_seq = -1;
			my $orig_ts = -1;
			my $recv_ts = -1;
			my $tran_ts = -1;
			if ($reply_type == ICMP_TIMESTAMP_REPLY) {
				if (length($recv_msg) >= $pl_offset + 20) {
					($reply_id, $reply_seq, $orig_ts, $recv_ts, $tran_ts) = unpack("n2 N3", substr($recv_msg, $pl_offset + 4, 16));
				}
			}

			if ($reply_id == $id && $reply_seq == $seq) {
				return ($orig_ts, $recv_ts, $tran_ts, $end_ts);
			} else {
				next;
			}
		}

		# Timed out
		$done = 1;
	}

	# If we reach here we didn't receive a response
	return ();
}

# Round to the nearest integer
sub round {
        my ($value) = @_;

        return int($value + 0.5);
}

# Get a formatted localtime string for the current time,
# including milliseconds. Do our own rounding to avoid
# sprintf()'s banker's rounding.
sub get_time {
	my $time = scalar(gettimeofday());

	my $secs = int($time);
	my $millis = &round(($time - $secs) * 1000);

	if ($millis == 1000) {
	        $secs += 1;
	        $millis = 0;
	}

	$millis = sprintf("%03d", $millis);

	if ($raw_timestamps) {
		return "$secs.$millis";
	}

	my @localtime = localtime($secs);
	my $date_time = strftime("%a %b %e %H:%M:%S", @localtime);
	my $year = strftime("%Y", @localtime);
	
	return "$date_time.$millis $year";
}

sub update_icmp_offset {
	my ($request_time, $response_time) = @_;

	lock(%reflector_offsets);

	my $minimum_half_rtt = int(&get_icmp_minimum_rtt($request_time + $response_time) / 2);

	# First ping. Start with an offset of 0.
	if (!defined($offset)) { $offset = 0; }
	
	# Adjust the offset if necessary
	if ($request_time + $offset < $minimum_half_rtt) {
		$offset = $minimum_half_rtt - $request_time;
	} elsif ($response_time - $offset < $minimum_half_rtt) {
		$offset = $response_time - $minimum_half_rtt;
	}

	return $offset;
}

sub get_icmp_minimum_rtt {
	my ($new_sample) = @_;

	if (!defined($minimum_rtt) || $new_sample < $minimum_rtt) {
		$minimum_rtt = $new_sample;
	}
	
	return $minimum_rtt;
}

# There are a variety of situations in which ICMP timestamps
# can be inconsistent. This subroutine attempts to handle those
# situations and correct the timestamps so we can calculate
# accurate request and response times. The corrected timestamps
# are returned in an array.
sub correct_icmp_timestamps {
	my ($icmp_orig, $icmp_recv, $icmp_tran, $icmp_end) = @_;

	# Calculate request and response times based on the raw timestamps
	my $ul_time = $icmp_recv - $icmp_orig;
	my $dl_time = $icmp_end - $icmp_tran;
	
	# The offset attempts to compensate for a stable(ish)
	# difference between the destination's timestamps and our
	# timestamps.
	if (!defined($offset)) {
		# This must be the first ping.
		# Calculate the offset based on the raw results.
		&update_icmp_offset($ul_time, $dl_time);
	}
	
	# Apply the current offset to the results
	$ul_time += $offset;
	$dl_time -= $offset;
	
	# Regardless of what the destination's timestamp is based on,
	# both our timer and the destination's will be reset to zero at
	# some point during the day, which will cause problems if
	# our timer has been reset but the destination's hasn't, or
	# vice versa. This is most likely to happen around midnight
	# UTC, but could happen at any time if a destination's timer is
	# relative to a time other than midnight UTC.
	#
	# There are four scenarios that need action:
	#
	# 1. Our timer has been reset to zero before the request was
	#    sent, but the destination's hasn't
	# 2. The destination's timer has been reset to zero before the
	#    was received, but ours hasn't
	# 3. Our timer resets to zero between sending the request
	#    and receiving the response
	# 4. The destination's timer resets to zero between receiving
	#    the request and sending the response
	#
	# The following code checks whether there is a large disparity
	# between this result and the previous result(s) for this
	# destination. If there is a large disparity, it might be for one
	# of the reasons listed above, in which case we can correct it
	# by adding a day's worth of millseconds to the appropriate
	# timestamps.
	#
	# If the result still looks weird after trying to correct for
	# timer resets it means the destination is probably returning
	# nonsensical timestamps (i.e. not based on a timer at all).

	# First, check whether the request/response times look sensible
	# after applying the current offset for this destination.
	# If either of them is negative or greater than our ICMP timeout
	# we might have a problem.
	my $icmp_timeout_ms = $timeout * 1000;
	if (
		$ul_time < 0 || $ul_time > $icmp_timeout_ms ||
		$dl_time < 0 || $dl_time > $icmp_timeout_ms
	) {
		# Record the pre-correction timestamps
		my $icmp_orig_before = $icmp_orig;
		my $icmp_recv_before = $icmp_recv;
		my $icmp_tran_before = $icmp_tran;
		my $icmp_end_before  = $icmp_end;

		# The following code effectively checks whether the offset of the 
		# destination's timestamps has changed by more than $icmp_timeout
		# in either direction. This should only happen if the ICMP timestamps
		# are excessively variable (i.e. nonsensical) or a timer reset has
		# occurred as described above.

		if ($icmp_recv + $offset + $icmp_timeout_ms < $icmp_orig) {
			# The destination's timer might have been reset before it received
			# the request, but ours was not
			$icmp_recv += 86400000;
			$icmp_tran += 86400000;
		} elsif ($icmp_tran + $offset + $icmp_timeout_ms < $icmp_orig) {
			# The destination's timer might have been reset before it sent the
			# response, but ours was not
			$icmp_tran += 86400000;
		}
			
		if ($icmp_recv + $offset > $icmp_orig + $icmp_timeout_ms) {
			# Our timer might have been reset before we sent the request,
			# but the destination's wasn't
			$icmp_orig += 86400000;
			$icmp_end += 86400000;
		} elsif ($icmp_tran + $offset > $icmp_end + $icmp_timeout_ms) {
			# Our timer might have been reset before the destination sent the
			# response, but the destination's wasn't
			$icmp_end += 86400000;
		}
		
		# If we tried to correct this result let's see if it worked.
		# If we didn't attempt a correction (i.e. the disparity wasn't large enough)
		# we'll just fall through and adjust the offset based on the new result.
		if (
			$icmp_orig_before != $icmp_orig ||
			$icmp_recv_before != $icmp_recv ||
			$icmp_tran_before != $icmp_tran ||
			$icmp_end_before != $icmp_end
		) {
			# Recalculate the request/response times again and see if
			# they look more sensible now.
			$ul_time = $icmp_recv - $icmp_orig + $offset;
			$dl_time = $icmp_end - $icmp_tran - $offset;
			if (
				$ul_time < 0 || $ul_time > $icmp_timeout_ms ||
				$dl_time < 0 || $dl_time > $icmp_timeout_ms
			) {
				# The times still look weird. Nothing else we can try
				# so just return the original results.
				
				# It's possible that the offset has changed legitimately, for example
				# due a clock update either on our side or the destination's side.
				# So we'll update the offset based on the current results (before we
				# tried to correct them). If this was a legitimate offset change the
				# results should be ok next time.
				&update_icmp_offset(($icmp_recv_before - $icmp_orig_before), ($icmp_end_before - $icmp_tran_before));
			
				return ($icmp_orig_before, $icmp_recv_before, $icmp_tran_before, $icmp_end_before);
			}
		}
	}
	
	# If we reach here the result is acceptable, either before or after correction.
	
	# Update the offset based on the (corrected) ICMP timestamps, and apply it
	&update_icmp_offset(($icmp_recv - $icmp_orig), ($icmp_end - $icmp_tran));
	$icmp_recv += $offset;
	$icmp_tran += $offset;
	
	return ($icmp_orig, $icmp_recv, $icmp_tran, $icmp_end);
}
